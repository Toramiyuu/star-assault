---
phase: 01-hud-orb-clarity
plan: "04"
type: execute
wave: 4
depends_on:
  - "01-03"
files_modified:
  - src/scenes/GameScene.js
  - src/systems/GroundDropManager.js
autonomous: false
gap_closure: true
requirements:
  - VISC-03

must_haves:
  truths:
    - "Picking up a heart drop causes the health bar to visibly animate upward to the new HP value"
    - "Picking up a shield drop causes the shield bar to visibly animate upward to the new shield value"
    - "After shield recharge fires (4s cooldown + 1s/pip), the shield bar animates upward — it does not snap or flash"
  artifacts:
    - path: "src/scenes/GameScene.js"
      provides: "Shield recharge path calls hud.update() immediately after incrementing playerShieldCurrent"
      contains: "this.hud.update"
    - path: "src/systems/GroundDropManager.js"
      provides: "Heart and shield pickup collect handlers call hud.update() after mutating hp/shield values"
      contains: "scene.hud.update"
  key_links:
    - from: "src/scenes/GameScene.js updateShieldRecharge()"
      to: "src/systems/HUD.js update()"
      via: "this.hud.update(this.score, this.hp) called immediately after playerShieldCurrent increment"
      pattern: "hud\\.update"
    - from: "src/systems/GroundDropManager.js _collectDrop() case 'heart'"
      to: "src/systems/HUD.js update()"
      via: "scene.hud.update(scene.score, scene.hp) called after scene.hp increment"
      pattern: "scene\\.hud\\.update"
    - from: "src/systems/GroundDropManager.js _collectDrop() case 'shield'"
      to: "src/systems/HUD.js update()"
      via: "scene.hud.update(scene.score, scene.hp) called after scene.playerShieldCurrent increment"
      pattern: "scene\\.hud\\.update"
---

<objective>
Wire HUD update calls to the two missing mutation sites — shield recharge increment and pickup grants — so the HUD bars animate in response to every state change, not just damage.

Purpose: gap-02 and gap-03 share the same root pattern: game state (playerShieldCurrent, hp) changes without the HUD being told to re-evaluate that frame. The dirty-flag tween in HUD.update() already works (gap-01 confirmed), but it only fires when HUD.update() is called with the new value. The recharge and pickup paths both mutate state correctly, but rely on the next-frame HUD.update() call to pick up the change. The fix is to call hud.update() immediately in each mutation site so the tween starts the same frame the value changes — not one frame later.

Output: Two files modified — GameScene.js (recharge path) and GroundDropManager.js (heart + shield pickup handlers). Both call hud.update() immediately after mutating the relevant stat.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-hud-orb-clarity/01-CONTEXT.md
@.planning/phases/01-hud-orb-clarity/01-03-SUMMARY.md
@src/scenes/GameScene.js
@src/systems/HUD.js
@src/systems/GroundDropManager.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire hud.update() after every hp/shield mutation in recharge and pickup paths</name>
  <files>src/scenes/GameScene.js, src/systems/GroundDropManager.js</files>
  <action>
Both gaps share one root pattern: the HUD's dirty-flag tween only fires when HUD.update() is called with a changed value. The frame-loop call at GameScene.js line 458 handles damage correctly because damage happens mid-frame and HUD.update() runs at end-of-frame. But recharge and pickups may produce visible lag or snap depending on frame ordering. The fix is to call hud.update() immediately after each mutation so the tween starts that same frame without ambiguity.

**BEFORE MAKING CHANGES: read both files to get exact current line numbers and text.**

---

**Fix A — GameScene.js: shield recharge increment (gap-02)**

Find `updateShieldRecharge(delta)` in `src/scenes/GameScene.js`. The relevant block is:

```javascript
if (this.shieldRechargeTimer >= SHIELD_RECHARGE_RATE) {
  this.shieldRechargeTimer -= SHIELD_RECHARGE_RATE;
  this.playerShieldCurrent = Math.min(
    this.playerShieldCurrent + 1,
    this.playerShield
  );
  this.audio.playShieldRecharge();
}
```

After `this.audio.playShieldRecharge();`, add one line:

```javascript
  if (this.hud) this.hud.update(this.score, this.hp);
```

So the block becomes:

```javascript
if (this.shieldRechargeTimer >= SHIELD_RECHARGE_RATE) {
  this.shieldRechargeTimer -= SHIELD_RECHARGE_RATE;
  this.playerShieldCurrent = Math.min(
    this.playerShieldCurrent + 1,
    this.playerShield
  );
  this.audio.playShieldRecharge();
  if (this.hud) this.hud.update(this.score, this.hp);
}
```

The `if (this.hud)` guard is defensive — hud always exists during gameplay but this prevents any null-ref during teardown.

Do NOT change anything else in `updateShieldRecharge()`. Do NOT move or touch the existing `this.hud.update()` call in the main update loop — that call stays and is harmless (dirty-flag means duplicate calls are no-ops).

---

**Fix B — GroundDropManager.js: heart pickup (gap-03)**

Find `_collectDrop(drop)` in `src/systems/GroundDropManager.js`, specifically `case 'heart':`:

```javascript
case 'heart': {
  scene.hp = Math.min(scene.hp + 1, scene.playerMaxHP);
  scene.showFloatingText(drop.x, drop.y - 20, '+1 HP', '#44ff44');
  break;
}
```

After `scene.showFloatingText(...)` and before `break`, add:

```javascript
  if (scene.hud) scene.hud.update(scene.score, scene.hp);
```

So it becomes:

```javascript
case 'heart': {
  scene.hp = Math.min(scene.hp + 1, scene.playerMaxHP);
  scene.showFloatingText(drop.x, drop.y - 20, '+1 HP', '#44ff44');
  if (scene.hud) scene.hud.update(scene.score, scene.hp);
  break;
}
```

---

**Fix C — GroundDropManager.js: shield pickup (gap-03)**

Find `case 'shield':` in `_collectDrop(drop)`:

```javascript
case 'shield': {
  scene.playerShieldCurrent = Math.min(
    scene.playerShieldCurrent + 1,
    scene.playerShield
  );
  scene.showFloatingText(drop.x, drop.y - 20, '+1 SHIELD', '#44ffff');
  break;
}
```

After `scene.showFloatingText(...)` and before `break`, add:

```javascript
  if (scene.hud) scene.hud.update(scene.score, scene.hp);
```

So it becomes:

```javascript
case 'shield': {
  scene.playerShieldCurrent = Math.min(
    scene.playerShieldCurrent + 1,
    scene.playerShield
  );
  scene.showFloatingText(drop.x, drop.y - 20, '+1 SHIELD', '#44ffff');
  if (scene.hud) scene.hud.update(scene.score, scene.hp);
  break;
}
```

---

**Do NOT touch:**
- The existing `this.hud.update(this.score, this.hp)` call in GameScene.update() — leave it
- Any other switch cases in `_collectDrop()` (bomb, magnet, boost, elite_shard) — they don't mutate hp or shield
- The `damagePlayer()` method — that path already works
- Any HUD.js code — no changes needed there
  </action>
  <verify>
    <automated>grep -n "scene\.hud\.update\|if (this\.hud) this\.hud\.update\|if (scene\.hud) scene\.hud\.update" src/scenes/GameScene.js src/systems/GroundDropManager.js</automated>
    <manual>Confirm output shows three new hud.update() calls:
1. GameScene.js — one inside updateShieldRecharge(), after playShieldRecharge()
2. GroundDropManager.js — one inside case 'heart', after showFloatingText
3. GroundDropManager.js — one inside case 'shield', after showFloatingText</manual>
    <sampling_rate>After this task, before checkpoint</sampling_rate>
  </verify>
  <done>Three explicit hud.update() calls added — one in the shield recharge increment block, one after hp pickup, one after shield pickup. The grep confirms all three are present. No other code changed.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <name>Task 2: Verify HUD bars update on pickup and shield recharge</name>
  <files>none</files>
  <action>Human runtime verification that HP bar responds to heart pickups, shield bar responds to shield pickups, and shield bar tweens upward on recharge.</action>
  <verify>
    <automated>echo "checkpoint — manual browser verification required"</automated>
    <manual>
Run `npm run dev` and open the game in the browser. Start a new game. Perform these three tests in order:

**Test 1 — Heart pickup (gap-03 HP bar):**
1. Turn on god mode (press I) so you can take damage without dying.
2. Take 1-2 hits to deplete some HP so the HP bar is not full.
3. Walk over a heart drop (red circle on the ground, labeled HP).
Expected: The green health bar visibly slides UPWARD over ~150ms to the new HP value. A "+1 HP" floating text appears simultaneously.
NOT expected: Bar does not change, or jumps instantly with no animation.

**Test 2 — Shield pickup (gap-03 shield bar):**
1. Take enough hits to deplete the blue shield bar to 0 (or partially).
2. Walk over a shield drop (cyan hexagon, labeled SH).
Expected: The blue shield bar visibly slides UPWARD over ~150ms to reflect the gained shield pip. A "+1 SHIELD" floating text appears.
NOT expected: Bar does not change, or snaps to the new value instantly.

**Test 3 — Shield recharge animation (gap-02):**
1. With god mode OFF, take 1 hit to remove the shield pip.
2. Do NOT take more damage. Wait at least 5 seconds (4s cooldown + recharge).
3. Watch the blue shield bar closely.
Expected: The shield bar smoothly tweens UPWARD from empty toward full as the pip refills — a visible ~150ms slide, not a flash or instant jump.
NOT expected: Bar snaps to full in a single frame, or bar does not change at all.

If all three bars animate correctly, type "approved".
If any test fails, describe: which test, what you see (e.g. "bar still snaps", "no animation", "bar doesn't move").
    </manual>
  </verify>
  <done>User types "approved" confirming all three tests pass — HP bar animates on pickup, shield bar animates on pickup, shield bar tweens upward on recharge. gap-02 and gap-03 closed.</done>
</task>

</tasks>

<verification>
Gap closure checklist:
- [ ] GameScene.js: `if (this.hud) this.hud.update(this.score, this.hp)` present inside `updateShieldRecharge()` after `playShieldRecharge()` call
- [ ] GroundDropManager.js: `if (scene.hud) scene.hud.update(scene.score, scene.hp)` present in `case 'heart':` handler
- [ ] GroundDropManager.js: `if (scene.hud) scene.hud.update(scene.score, scene.hp)` present in `case 'shield':` handler
- [ ] No other code in either file changed
- [ ] Human confirms: heart pickup animates HP bar up
- [ ] Human confirms: shield pickup animates shield bar up
- [ ] Human confirms: shield recharge tweens bar up (no snap/flash)
</verification>

<success_criteria>
- Heart pickup: HP bar visibly slides up ~150ms to new value — confirmed in Task 2
- Shield pickup: shield bar visibly slides up ~150ms to new value — confirmed in Task 2
- Shield recharge: shield bar tweens upward (not snaps/flashes) — confirmed in Task 2
- grep shows three new hud.update() calls in the correct locations
- No Phaser console errors during gameplay
- No regression: existing damage animations (bar slides down on hit) still work
</success_criteria>

<output>
After completion, create `.planning/phases/01-hud-orb-clarity/01-04-SUMMARY.md`
</output>
