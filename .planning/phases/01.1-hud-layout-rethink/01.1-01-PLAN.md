---
phase: 01.1-hud-layout-rethink
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/systems/HUD.js
autonomous: true
requirements:
  - VISC-03

must_haves:
  truths:
    - "Shield and HP bars render at ~194px CSS width on a 375px viewport — visually prominent, no squinting required"
    - "XP bar spans near-full screen width (~319px CSS) anchored to bottom safe zone — visible at a glance during combat"
    - "Kill streak counter and wave text use 48-52px font at canvas resolution — legible without pausing"
    - "Shield and HP bar cluster sits at Y=160/200 — below device notch safe zone, not obscuring center play area"
    - "Boss bar Y is updated to avoid collision with the enlarged shield/HP cluster"
    - "All HUD layout values are named constants at module top — no hardcoded coordinates inside methods"
    - "Emoji icons replaced with text labels (SH / HP) in matching bar accent colors — cross-platform consistent"
    - "hudBg gradient coverage updated to cover the new taller top-area layout"
    - "XP bar background gradient drawn at new bottom position — readable against gameplay background"
    - "The _shieldProxy / _healthProxy tween proxy pattern is completely preserved — ratio property names unchanged"
  artifacts:
    - path: "src/systems/HUD.js"
      provides: "Resized, repositioned HUD with all constants extracted"
      contains: "BAR_W = 560"
    - path: "src/systems/HUD.js"
      provides: "XP bar at bottom safe zone"
      contains: "XP_BAR_Y = 1760"
    - path: "src/systems/HUD.js"
      provides: "Boss bar below enlarged top HUD"
      contains: "BOSS_BAR_Y"
  key_links:
    - from: "src/systems/HUD.js constructor"
      to: "_drawBarBg()"
      via: "BAR_W, BAR_H, BAR_X, SHIELD_Y, HEALTH_Y, CORNER_R constants"
      pattern: "_drawBarBg\\(.*BAR_X.*SHIELD_Y"
    - from: "src/systems/HUD.js update()"
      to: "_shieldProxy.ratio / _healthProxy.ratio"
      via: "fillRoundedRect using BAR_X, SHIELD_Y, BAR_H, BAR_W constants"
      pattern: "BAR_X.*SHIELD_Y.*BAR_H.*BAR_W"
    - from: "src/systems/HUD.js updateXPBar()"
      to: "xpBarFill draw call"
      via: "XP_BAR_X, XP_BAR_Y, XP_BAR_W, XP_BAR_H constants"
      pattern: "XP_BAR_X.*XP_BAR_Y"
    - from: "src/systems/HUD.js showBossHP()"
      to: "boss bar draw call"
      via: "BOSS_BAR_W, BOSS_BAR_H, BOSS_BAR_Y constants"
      pattern: "BOSS_BAR_Y"
---

<objective>
Resize and reposition all HUD elements in HUD.js to Survivor.io-quality clarity at 1080x1920 canvas resolution. The shield/HP bars grow from 220x14px to 560x30px and move from Y=24/44 to Y=160/200 (below notch safe zone). The XP bar moves from Y=85 (top, cluttered) to Y=1760 (bottom safe zone) and widens from 400px to 920px. All font sizes increase to 48-52px. All hardcoded coordinates are extracted to named constants at module top.

Purpose: Players currently cannot read the HUD at actual mobile viewport size (bars render at 76px wide, 5px tall — physically smaller than a matchstick). This plan makes the HUD meet the readability bar set by Survivor.io conventions.
Output: Modified src/systems/HUD.js with Survivor.io-quality layout constants, repositioned elements, text labels replacing emoji icons.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@src/systems/HUD.js
@.planning/phases/01.1-hud-layout-rethink/01.1-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract all layout constants and resize/reposition HUD elements</name>
  <files>src/systems/HUD.js</files>
  <action>
Replace the existing 6-constant block at the top of HUD.js with a complete set of named constants covering every layout value currently hardcoded inside methods and the constructor. Then update every reference site inside the class to use the named constant.

**Step 1 — Replace the constants block (lines 3-8 of current HUD.js):**

```javascript
// ── Layout constants (all HUD coordinates in 1080x1920 canvas px) ──────────
const BAR_W    = 560;   // shield/HP bar width   (was 220 — renders 194px CSS at 375px viewport)
const BAR_H    = 30;    // shield/HP bar height  (was 14  — renders ~10px CSS, visible bar)
const BAR_X    = 80;    // bar left edge         (was 60)
const SHIELD_Y = 160;   // shield bar center Y   (was 24  — below notch safe zone)
const HEALTH_Y = 200;   // HP bar center Y       (was 44  — 40px gap between bars)
const CORNER_R = 6;     // border-radius         (was 3   — proportional to larger bar)

const XP_BAR_W = 920;                            // XP bar width (was 400)
const XP_BAR_H = 20;                             // XP bar height (was 12)
const XP_BAR_X = (1080 - XP_BAR_W) / 2;         // centered (use literal 1080, not GAME.WIDTH — GAME may not be in scope at module level if needed, but GAME is already imported so use GAME.WIDTH)
const XP_BAR_Y = 1760;                           // bottom safe zone (was 85 at top)

const BOSS_BAR_W = 700;                          // boss bar width (was 600)
const BOSS_BAR_H = 28;                           // boss bar height (was 24)
const BOSS_BAR_Y = 240;                          // below HEALTH_Y cluster (was 110, conflicted with new bars)
// boss bar X is always centered: (GAME.WIDTH - BOSS_BAR_W) / 2
```

NOTE: XP_BAR_X uses GAME.WIDTH so must stay inside the class or use the literal 1080. Since GAME is imported at module top, `const XP_BAR_X = (GAME.WIDTH - XP_BAR_W) / 2;` is fine.

**Step 2 — Update the constructor:**

a) **hudBg gradient** — update to cover new top-area height. The shield/HP cluster now extends to Y=HEALTH_Y + BAR_H/2 = 215px. Wave text at ~Y=80 and score at ~Y=80 are above SHIELD_Y. Update coverage:
```javascript
hudBg.fillStyle(0x000000, 0.5);
hudBg.fillRect(0, 0, GAME.WIDTH, 230);   // covers top element cluster including HP bar
hudBg.fillStyle(0x000000, 0.25);
hudBg.fillRect(0, 230, GAME.WIDTH, 40);  // fade edge
```

b) **Score text** — move to top-right at Y=60 (gives room below score for wave text):
```javascript
this.scoreText = scene.add.text(GAME.WIDTH - 40, 60, '0', {
    fontFamily: 'Arial',
    fontSize: '52px',
    ...
}).setOrigin(1, 0).setDepth(100).setScrollFactor(0);
```

c) **Wave text** — stay top-center but move to Y=60, increase font to 48px:
```javascript
this.waveText = scene.add.text(GAME.WIDTH / 2, 60, 'WAVE 1', {
    fontFamily: 'Arial',
    fontSize: '48px',
    ...
}).setOrigin(0.5, 0).setDepth(100).setScrollFactor(0);
```

d) **Streak text** — top-right, Y=10 (above score), increase base font size to 36px:
```javascript
this.streakText = scene.add.text(GAME.WIDTH - 40, 10, '', {
    fontFamily: 'Arial',
    fontSize: '36px',
    ...
}).setOrigin(1, 0).setDepth(101).setScrollFactor(0);
```
Also update `updateStreak()` font sizes: streak>=20 -> 40px, streak>=10 -> 38px, default -> 36px.

e) **Shield icon** — replace emoji with text label "SH" in blue, positioned left of bar:
```javascript
this.shieldIcon = scene.add.text(BAR_X - 10, SHIELD_Y, 'SH', {
    fontFamily: 'Arial',
    fontSize: '28px',
    color: '#4488ff',
    fontStyle: 'bold',
    stroke: '#000000',
    strokeThickness: 2,
}).setOrigin(1, 0.5).setDepth(101).setScrollFactor(0);
```

f) **Health icon** — replace emoji with text label "HP" in red:
```javascript
this.healthIcon = scene.add.text(BAR_X - 10, HEALTH_Y, 'HP', {
    fontFamily: 'Arial',
    fontSize: '28px',
    color: '#ff4444',
    fontStyle: 'bold',
    stroke: '#000000',
    strokeThickness: 2,
}).setOrigin(1, 0.5).setDepth(101).setScrollFactor(0);
```

g) **XP bar background draw** — use new constants, draw at bottom:
```javascript
// XP bar background at bottom safe zone
const xpBotGrad = scene.add.graphics().setDepth(99).setScrollFactor(0);
xpBotGrad.fillStyle(0x000000, 0.45);
xpBotGrad.fillRect(0, XP_BAR_Y - XP_BAR_H - 20, GAME.WIDTH, XP_BAR_H + 50);

this.xpBarBg.fillStyle(0x333333, 0.8);
this.xpBarBg.fillRect(XP_BAR_X, XP_BAR_Y - XP_BAR_H / 2, XP_BAR_W, XP_BAR_H);
this.xpBarBg.lineStyle(1, 0xFF6600, 0.5);
this.xpBarBg.strokeRect(XP_BAR_X, XP_BAR_Y - XP_BAR_H / 2, XP_BAR_W, XP_BAR_H);
```

h) **XP level text** — reposition to bottom-left of XP bar, larger font:
```javascript
this.xpLevelText = scene.add.text(XP_BAR_X, XP_BAR_Y + XP_BAR_H / 2 + 8, 'LV 0', {
    fontFamily: 'Arial',
    fontSize: '36px',
    color: '#FF8800',
    fontStyle: 'bold',
    stroke: '#000000',
    strokeThickness: 2,
}).setOrigin(0, 0).setDepth(101).setScrollFactor(0);
```

**Step 3 — Update `update()` method:**

The shield and health fill draw calls reference BAR_X, SHIELD_Y, HEALTH_Y, BAR_W, BAR_H, CORNER_R directly — they will automatically use the new values since they reference the module-level constants. No changes needed in the draw coordinates inside `update()` as long as they already use the named constants (verify: lines 163-167 and 208-211 in current file use `BAR_X`, `SHIELD_Y`, `BAR_H`, `BAR_W`, `CORNER_R` — these will pick up the new values automatically).

Shield glow also uses BAR_X, SHIELD_Y, BAR_W, BAR_H, CORNER_R — will auto-update.

**Step 4 — Update `updateXPBar()` method:**

Replace the 4 hardcoded local variables with the module-level constants:
```javascript
updateXPBar(current, threshold, level) {
    // Uses module-level XP_BAR_W, XP_BAR_H, XP_BAR_X, XP_BAR_Y constants
    this.xpBarFill.clear();
    const ratio = Math.min(current / Math.max(threshold, 1), 1);
    this.xpBarFill.fillStyle(0xFF6600, 1);
    this.xpBarFill.fillRect(
        XP_BAR_X + 1,
        XP_BAR_Y - XP_BAR_H / 2 + 1,
        (XP_BAR_W - 2) * ratio,
        XP_BAR_H - 2
    );
    this.xpLevelText.setText(`LV ${level}`);
}
```

**Step 5 — Update `showBossHP()` method:**

Replace the 4 hardcoded local variables with the module-level constants:
```javascript
showBossHP(current, max) {
    const barX = (GAME.WIDTH - BOSS_BAR_W) / 2;

    if (!this.bossBarBg) {
        this.bossBarBg = this.scene.add.graphics().setDepth(100).setScrollFactor(0);
        this.bossBarFill = this.scene.add.graphics().setDepth(101).setScrollFactor(0);
        this.bossLabel = this.scene.add.text(GAME.WIDTH / 2, BOSS_BAR_Y - 22, 'BOSS', {
            fontFamily: 'Arial',
            fontSize: '26px',
            color: '#ff4444',
            fontStyle: 'bold',
            stroke: '#000000',
            strokeThickness: 3,
        }).setOrigin(0.5, 1).setDepth(101).setScrollFactor(0);
    }

    this.bossBarBg.clear();
    this.bossBarBg.fillStyle(0x333333, 0.8);
    this.bossBarBg.fillRect(barX, BOSS_BAR_Y, BOSS_BAR_W, BOSS_BAR_H);
    this.bossBarBg.lineStyle(2, 0xff4444, 1);
    this.bossBarBg.strokeRect(barX, BOSS_BAR_Y, BOSS_BAR_W, BOSS_BAR_H);

    this.bossBarFill.clear();
    const ratio = Math.max(0, current / max);
    const color = ratio > 0.5 ? 0xff4444 : ratio > 0.25 ? 0xff8800 : 0xffcc00;
    this.bossBarFill.fillStyle(color, 1);
    this.bossBarFill.fillRect(barX + 2, BOSS_BAR_Y + 2, (BOSS_BAR_W - 4) * ratio, BOSS_BAR_H - 4);
}
```

**Step 6 — Update `updateStreak()` font sizes (larger at new scale):**
```javascript
updateStreak(streak) {
    if (streak <= 0) {
        this.streakText.setVisible(false);
    } else {
        this.streakText.setVisible(true);
        if (streak >= 20) {
            this.streakText.setText(`x${streak} UNSTOPPABLE`);
            this.streakText.setColor('#ff4444');
            this.streakText.setFontSize(40);
        } else if (streak >= 10) {
            this.streakText.setText(`x${streak} ON FIRE`);
            this.streakText.setColor('#ff8800');
            this.streakText.setFontSize(38);
        } else {
            this.streakText.setText(`x${streak}`);
            this.streakText.setColor('#ffffff');
            this.streakText.setFontSize(36);
        }
    }
}
```

**Critical preservation rules:**
- Do NOT touch `_shieldProxy`, `_healthProxy`, `_shieldRatioTarget`, `_healthRatioTarget`, `_shieldTween`, `_healthTween` — these are the Phase 1 tween proxy pattern and must remain exactly as-is
- The fill draw calls in `update()` already use the named constants — they will pick up new values automatically, but verify each uses `BAR_X`, `SHIELD_Y/HEALTH_Y`, `BAR_H`, `BAR_W`, `CORNER_R` (not hardcoded numbers)
- HUD.js uses 4-space indentation — match this throughout

**Bar icon X positioning note:** BAR_X is now 80. The "SH" and "HP" labels use `.setOrigin(1, 0.5)` so their right edge sits at BAR_X - 10 = 70px from canvas left. This gives a visible gap between label and bar. If the label is too close to the canvas left edge (GAME.WIDTH = 1080, left margin = 40px minimum), check that 70px is adequate — it is (70 > 40).
  </action>
  <verify>
    <automated>node -e "const fs = require('fs'); const src = fs.readFileSync('src/systems/HUD.js', 'utf8'); const checks = ['BAR_W = 560', 'BAR_H = 30', 'BAR_X = 80', 'SHIELD_Y = 160', 'HEALTH_Y = 200', 'XP_BAR_W = 920', 'XP_BAR_Y = 1760', 'BOSS_BAR_Y', '_shieldProxy', '_healthProxy', 'XP_BAR_X', 'XP_BAR_Y - XP_BAR_H']; const missing = checks.filter(c => !src.includes(c)); if (missing.length) { console.error('MISSING:', missing); process.exit(1); } console.log('PASS — all constants and patterns present');"</automated>
    <manual>Open the game in browser (npm run dev), open DevTools, set viewport to 375px wide. Play to wave 1. Confirm: shield bar is a wide visible strip at top-left, HP bar below it, both clearly readable. XP bar appears as a wide strip near the bottom of the screen. Wave text and score text are legible without zooming.</manual>
    <sampling_rate>Run automated check immediately after writing HUD.js. Run manual check after the game loads in browser.</sampling_rate>
  </verify>
  <done>HUD.js passes the node constant-presence check. All 12 layout values are named constants. No hardcoded coordinates remain in showBossHP(), updateXPBar(), or the constructor text/graphics positions. The _shieldProxy/_healthProxy pattern is untouched.</done>
</task>

<task type="auto">
  <name>Task 2: Add dirty-flag guards to shield and HP bar fill redraws</name>
  <files>src/systems/HUD.js</files>
  <action>
The current `update()` method calls `shieldBarFill.clear()` and `healthBarFill.clear()` every frame unconditionally — even when the ratio hasn't changed. With BAR_W enlarged from 220 to 560 (2.5x area), this per-frame cost grows proportionally. The dirty-flag pattern needs guards on the fill redraws (not the glow, which must pulse every frame).

The tween proxy already tracks the animated value in `this._shieldProxy.ratio` and `this._healthProxy.ratio`. Add tracking variables for the last-drawn ratio and skip the clear+fill when unchanged.

**Step 1 — Add tracking variables in the constructor** (after the existing `_shieldTween = null` and `_healthTween = null` lines):
```javascript
this._lastShieldRatioDrawn = -1;   // dirty-flag: last ratio actually rendered to shieldBarFill
this._lastHealthRatioDrawn = -1;   // dirty-flag: last ratio actually rendered to healthBarFill
```

**Step 2 — Guard the shield fill redraw in `update()`:**

Locate the current unconditional block:
```javascript
        this.shieldBarFill.clear();
        if (this._shieldProxy.ratio > 0) {
            this.shieldBarFill.fillStyle(0x4488ff, 1);
            this.shieldBarFill.fillRoundedRect(
                BAR_X + 1, SHIELD_Y - BAR_H / 2 + 1,
                (BAR_W - 2) * this._shieldProxy.ratio, BAR_H - 2,
                CORNER_R
            );
        }
```

Replace with:
```javascript
        const shieldRatioNow = this._shieldProxy.ratio;
        if (shieldRatioNow !== this._lastShieldRatioDrawn) {
            this._lastShieldRatioDrawn = shieldRatioNow;
            this.shieldBarFill.clear();
            if (shieldRatioNow > 0) {
                this.shieldBarFill.fillStyle(0x4488ff, 1);
                this.shieldBarFill.fillRoundedRect(
                    BAR_X + 1, SHIELD_Y - BAR_H / 2 + 1,
                    (BAR_W - 2) * shieldRatioNow, BAR_H - 2,
                    CORNER_R
                );
            }
        }
```

**Step 3 — Guard the health fill redraw in `update()`:**

The health bar also has an alpha pulse for low HP (`alpha = 0.6 + 0.4 * Math.sin(...)`) that changes every frame. The dirty-flag must account for this: the alpha value changes each frame when `hpCur <= 1`, which means the bar must redraw every frame in that state. The guard must be disabled when low-HP pulsing is active.

Locate the current unconditional block:
```javascript
        this.healthBarFill.clear();
        if (this._healthProxy.ratio > 0) {
            const color = this._getHealthColor(this._healthProxy.ratio);
            let alpha = 1;
            if (hpCur <= 1 && hpMax > 1) {
                alpha = 0.6 + 0.4 * Math.sin(scene.time.now * 0.008);
            }
            this.healthBarFill.fillStyle(color, alpha);
            this.healthBarFill.fillRoundedRect(
                BAR_X + 1, HEALTH_Y - BAR_H / 2 + 1,
                (BAR_W - 2) * this._healthProxy.ratio, BAR_H - 2,
                CORNER_R
            );
        }
```

Replace with:
```javascript
        const healthRatioNow = this._healthProxy.ratio;
        const lowHpPulsing = (hpCur <= 1 && hpMax > 1);
        if (healthRatioNow !== this._lastHealthRatioDrawn || lowHpPulsing) {
            if (!lowHpPulsing) {
                this._lastHealthRatioDrawn = healthRatioNow;
            }
            this.healthBarFill.clear();
            if (healthRatioNow > 0) {
                const color = this._getHealthColor(healthRatioNow);
                const alpha = lowHpPulsing
                    ? 0.6 + 0.4 * Math.sin(scene.time.now * 0.008)
                    : 1;
                this.healthBarFill.fillStyle(color, alpha);
                this.healthBarFill.fillRoundedRect(
                    BAR_X + 1, HEALTH_Y - BAR_H / 2 + 1,
                    (BAR_W - 2) * healthRatioNow, BAR_H - 2,
                    CORNER_R
                );
            }
        }
```

Note: `_lastHealthRatioDrawn` is intentionally not updated when `lowHpPulsing` is true — this ensures that when the player takes a hit and HP drops to 1, the next non-pulsing frame will still force a redraw (ratio changed) and `_lastHealthRatioDrawn` will be set correctly when pulsing stops.

**Important:** The shield glow (`shieldGlow.clear()` / `shieldGlow.fillRoundedRect()`) is intentionally NOT guarded — the glow pulses via `Math.sin(scene.time.now * 0.008)` and must redraw every frame to animate.

**Critical preservation rules:**
- Do NOT move or rename `_shieldProxy`, `_healthProxy` — these are Phase 1 canonical tween targets
- Do NOT remove the existing `_shieldRatioTarget` / `_healthRatioTarget` dirty-flag comparators — they prevent redundant tween creation (separate concern from per-frame redraw optimization)
- Match 4-space indentation of HUD.js throughout
  </action>
  <verify>
    <automated>node -e "const fs = require('fs'); const src = fs.readFileSync('src/systems/HUD.js', 'utf8'); const checks = ['_lastShieldRatioDrawn = -1', '_lastHealthRatioDrawn = -1', 'shieldRatioNow !== this._lastShieldRatioDrawn', 'lowHpPulsing', 'healthRatioNow !== this._lastHealthRatioDrawn || lowHpPulsing']; const missing = checks.filter(c => !src.includes(c)); if (missing.length) { console.error('MISSING dirty-flag guards:', missing); process.exit(1); } console.log('PASS — dirty-flag guards present');"</automated>
    <manual>None required beyond Task 1 manual check — dirty-flag correctness is verified by observing that bars still animate when taking damage and shield recharges.</manual>
    <sampling_rate>Run automated check after editing. Visual correctness confirmed by Task 1's manual check (shield and HP bars animate on damage/recharge).</sampling_rate>
  </verify>
  <done>HUD.js contains `_lastShieldRatioDrawn` and `_lastHealthRatioDrawn` tracking variables, and the shield/HP fill draw blocks are guarded so they skip clear+redraw on unchanged frames. The low-HP alpha pulse still redraws every frame. The shield glow still redraws every frame. The _shieldProxy/_healthProxy pattern is untouched.</done>
</task>

</tasks>

<verification>
After both tasks:

1. Run the node constant-check: `node -e "const fs = require('fs'); const src = fs.readFileSync('src/systems/HUD.js', 'utf8'); const checks = ['BAR_W = 560', 'XP_BAR_Y = 1760', 'BOSS_BAR_Y', '_lastShieldRatioDrawn', '_lastHealthRatioDrawn', '_shieldProxy', 'XP_BAR_W = 920']; const missing = checks.filter(c => !src.includes(c)); if (missing.length) { console.error('FAIL — missing:', missing); process.exit(1); } console.log('PASS');"` — must print PASS.

2. Start dev server (`npm run dev`), open in browser at 375px DevTools width. Observe:
   - Shield bar is a wide visible strip with "SH" label at top-left below score/wave row
   - HP bar is directly below it with "HP" label, clearly red, clearly sized
   - XP bar spans most of the bottom of the screen
   - Score and wave text are legible at a glance
   - No HUD element covers the center play area during normal gameplay

3. Take damage: both bars animate (tween, not snap) to new value. Shield recharge glow pulses. HP bar pulses when at 1 HP.
</verification>

<success_criteria>
1. `npm run dev` starts without errors
2. Node constant-check passes (BAR_W=560, XP_BAR_Y=1760, BOSS_BAR_Y, dirty-flag guards, tween proxy preserved)
3. At 375px DevTools viewport: shield/HP bars are visually prominent, XP bar covers bottom strip, all text is legible
4. Shield and HP bars animate on damage/recharge (tween proxy working)
5. No hardcoded coordinate literals remain inside `update()`, `updateXPBar()`, or `showBossHP()` — all use named constants
</success_criteria>

<output>
After completion, create `.planning/phases/01.1-hud-layout-rethink/01.1-01-SUMMARY.md` with:
- What was built (constants block, element positions, font sizes, dirty-flag guards)
- Key decisions made during execution
- Any deviations from the plan and why
- Final constant values used (BAR_W, BAR_H, XP_BAR_Y, etc.)
</output>