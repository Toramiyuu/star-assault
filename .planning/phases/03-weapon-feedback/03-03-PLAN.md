---
phase: 03-weapon-feedback
plan: 03
type: execute
wave: 2
depends_on:
  - 03-01
files_modified:
  - src/weapons/TwinLaser.js
  - src/scenes/GameScene.js
autonomous: true
requirements:
  - CMBT-02
  - POL-03

must_haves:
  truths:
    - "A pulsing cyan glow ring appears around the enemy currently in the TwinLaser beam while the beam is active"
    - "The enemy HP bar visibly decreases in real-time frame by frame while the TwinLaser is in contact — not snapping"
    - "Cyan/white spark particles continuously emit from the beam contact point while beam is active"
    - "After a TwinLaser kill, the glow ring lingers briefly at the kill position before the explosion triggers — ~100ms linger"
    - "Enemy HP bars use a dirty-flag guard — bars are not redrawn every frame when HP has not changed"
  artifacts:
    - path: "src/weapons/TwinLaser.js"
      provides: "Cyan glow ring drawn via graphics in drawEffects(); kill linger delay of ~100ms before killEnemy()"
      contains: "_lingerTarget"
    - path: "src/scenes/GameScene.js"
      provides: "drawEnemyHealthBars() uses _lastHPDrawn data key per enemy to skip redraw when HP unchanged"
      contains: "_lastHPDrawn"
  key_links:
    - from: "src/weapons/TwinLaser.js"
      to: "src/utils/CombatUtils.js"
      via: "killEnemy() called after 100ms linger (already wired in Plan 01)"
      pattern: "killEnemy"
    - from: "src/scenes/GameScene.js drawEnemyHealthBars"
      to: "enemy sprite data"
      via: "_lastHPDrawn stored on enemy via setData, compared each frame"
      pattern: "_lastHPDrawn"
---

<objective>
Add TwinLaser sustained visual feedback (CMBT-02: real-time HP bar drain, POL-03: cyan glow ring on target) and implement the kill linger effect. Also add per-frame dirty-flag guard to drawEnemyHealthBars() — the STATE.md performance blocker flagged as "must be addressed in the phase that first touches this system."

Purpose: Players need visible confirmation that the TwinLaser is working. The beam contact point should pulse, the HP bar should drain in real-time, and the kill should feel like the enemy "got cooked." The HP bar dirty-flag is a STATE.md-flagged concern that must close this phase.

Output: TwinLaser.drawEffects() with cyan glow ring + drawEnemyHealthBars() with dirty-flag guard
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/phases/03-weapon-feedback/03-CONTEXT.md
@.planning/phases/03-weapon-feedback/03-RESEARCH.md
@.planning/phases/03-weapon-feedback/03-01-SUMMARY.md
@src/weapons/TwinLaser.js
@src/scenes/GameScene.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add cyan glow ring and kill linger to TwinLaser</name>
  <files>src/weapons/TwinLaser.js</files>
  <action>
Two changes to TwinLaser.js:

**A — Kill linger in fire():**

After Plan 01, TwinLaser's `fire()` already calls `killEnemy(this.scene, e)` when `hp <= 0`. Modify this to store the kill position and delay the actual kill by ~100ms so the beam visually "lingers" on the enemy before it explodes.

In the `hp <= 0` branch inside `fire()`:
```js
if (hp <= 0) {
  // Linger: keep glow at this position for 100ms before explosion
  this._lingerTarget = { x: e.x, y: e.y, endTime: this.scene.time.now + 100 };
  // Deactivate enemy immediately so it can't be double-hit (setActive guard in killEnemy handles this)
  // but delay the kill call so drawEffects still has a target position to draw the glow
  const capturedE = e;
  this.scene.time.delayedCall(100, () => {
    killEnemy(this.scene, capturedE);
    if (this._lingerTarget && this._lingerTarget.endTime <= this.scene.time.now + 10) {
      this._lingerTarget = null;
    }
  });
  // Prevent the enemy from being processed again on next tick while linger is active
  e.setData('hp', 0); // HP is already <= 0, ensure it stays at 0
  break;
}
```

Also add `this._lingerTarget = null;` in the constructor.

**B — Cyan glow ring in drawEffects():**

In `drawEffects(graphics, time)`, inside the `for (const o of origins)` loop, after the existing spark flash code at the bottom (the `this.scene.enemies.getChildren().forEach(...)` block), add the cyan glow ring:

```js
// Cyan pulsing glow ring on enemies in beam path (POL-03)
const aimCos = Math.cos(aimAngle);
const aimSin = Math.sin(aimAngle);
this.scene.enemies.getChildren().forEach((e) => {
  if (!e.active) return;
  if (this._inBeam(o.x, o.y, e.x, e.y, aimCos, aimSin, halfW)) {
    const glowPulse = 0.4 + 0.3 * Math.sin(time * 0.015);
    // Outer glow ring — pulsing cyan
    graphics.lineStyle(8, 0x00eeff, glowPulse);
    graphics.strokeCircle(e.x, e.y, 34);
    // Inner highlight — dimmer white
    graphics.lineStyle(3, 0xffffff, glowPulse * 0.6);
    graphics.strokeCircle(e.x, e.y, 28);
  }
});

// Draw linger glow at stored position after kill (100ms window)
if (this._lingerTarget) {
  const lt = this._lingerTarget;
  if (this.scene.time.now <= lt.endTime) {
    const glowPulse = 0.6 + 0.4 * Math.sin(time * 0.025);
    graphics.lineStyle(12, 0x00eeff, glowPulse);
    graphics.strokeCircle(lt.x, lt.y, 38);
    graphics.lineStyle(4, 0xffffff, glowPulse * 0.8);
    graphics.strokeCircle(lt.x, lt.y, 30);
  } else {
    this._lingerTarget = null;
  }
}
```

NOTE: The existing spark flash code in drawEffects() already iterates enemies for sparks. The glow ring iteration is a second forEach on the same array — this is intentional so the glow ring draws OVER the spark, not under it. Both loops are inside the `for (const o of origins)` to allow the second beam origin to also draw glow rings on its targets.

However, to avoid drawing the glow ring twice (once per beam origin), move the glow ring code OUTSIDE the `for (const o of origins)` loop (after the loop ends). The glow ring is centered on the enemy, not the beam origin, so it only needs to be drawn once per enemy. Track whether any origin hits the enemy:

```js
// After the for (const o of origins) loop:
const aimCos2 = Math.cos(aimAngle);
const aimSin2 = Math.sin(aimAngle);
this.scene.enemies.getChildren().forEach((e) => {
  if (!e.active) return;
  for (const o of origins) {
    if (this._inBeam(o.x, o.y, e.x, e.y, aimCos2, aimSin2, halfW)) {
      const glowPulse = 0.4 + 0.3 * Math.sin(time * 0.015);
      graphics.lineStyle(8, 0x00eeff, glowPulse);
      graphics.strokeCircle(e.x, e.y, 34);
      graphics.lineStyle(3, 0xffffff, glowPulse * 0.6);
      graphics.strokeCircle(e.x, e.y, 28);
      break; // Only draw once per enemy regardless of which beam origin hits it
    }
  }
});
```
  </action>
  <verify>
    <automated>npm run build 2>&1 | tail -10</automated>
    <manual>npm run dev, get TwinLaser (P01 upgrade via U key), hold beam on an enemy — cyan pulsing ring should appear around the targeted enemy. Kill an enemy with laser — brief glow lingers at kill position before explosion appears.</manual>
  </verify>
  <done>Cyan glow ring pulses around enemies in the TwinLaser beam; kill linger draws glow ring for ~100ms at kill position; _lingerTarget properly nulled after expiry; build is clean</done>
</task>

<task type="auto">
  <name>Task 2: Add dirty-flag guard to drawEnemyHealthBars() in GameScene</name>
  <files>src/scenes/GameScene.js</files>
  <action>
The STATE.md blocker: "Per-frame Graphics.clear() redraw in hot paths (XP orbs, enemy HP bars, HUD bars) must be addressed in the phase that first touches each system."

`drawEnemyHealthBars()` in GameScene.js currently calls `this.enemyHPBars.clear()` every frame and redraws every visible enemy's bar, even when HP hasn't changed. This is expensive when 10+ enemies are on screen.

**Approach:** Track a global dirty flag per enemy using a new `_lastHPDrawn` data key. Skip clear+redraw if ALL enemies' HP and shield values are unchanged since last draw.

However, a per-enemy approach requires storing values per enemy and doing the clear/redraw selectively — but `this.enemyHPBars` is a single shared Graphics object so a partial clear isn't possible without individual Graphics per enemy (too expensive). Instead, use a frame-level "any changed" check:

```js
drawEnemyHealthBars() {
  // Check if any enemy HP or shield has changed since last draw
  let anyChanged = false;
  this.enemies.getChildren().forEach(e => {
    if (!e.active) return;
    const hp = e.getData('hp');
    const shield = e.getData('shield');
    const lastHP = e.getData('_lastHPDrawn');
    const lastShield = e.getData('_lastShieldDrawn');
    if (hp !== lastHP || shield !== lastShield) {
      anyChanged = true;
    }
  });

  if (!anyChanged) return; // Nothing changed — skip clear+redraw

  this.enemyHPBars.clear();
  this.enemies.getChildren().forEach(e => {
    if (!e.active) return;
    const hp = e.getData('hp');
    const maxHP = e.getData('maxHP');
    if (!maxHP || hp <= 0) return;

    // Store drawn values for dirty-flag check next frame
    e.setData('_lastHPDrawn', hp);
    e.setData('_lastShieldDrawn', e.getData('shield') || 0);

    // ... rest of bar drawing logic unchanged ...
  });
}
```

The existing bar drawing logic (background rect, color calculation, fill rect, shield pip loops) stays completely unchanged inside the forEach. Only the early-exit check and the setData() calls after the hp/maxHP guard are added.

**IMPORTANT:** The TwinLaser ticks damage every 100ms, meaning HP changes rapidly during laser contact — the dirty flag will correctly detect the change each tick and redraw. This is exactly the behavior needed for CMBT-02 (real-time HP drain while laser is active). The dirty flag doesn't prevent CMBT-02 from working — it only skips the redraw when HP truly hasn't changed.

**Additionally** — always visible HP bars requirement from CONTEXT.md: the current code has `if (!maxHP || hp <= 0) return;` which hides bars at full HP since the condition is met when `hp === maxHP`. Change to ALWAYS show bars from spawn:

The current code already has this correct (it draws when `hp > 0` and `maxHP > 0`) — bars at full HP ARE shown because the ratio is 1.0 (full green bar). The `if (!maxHP || hp <= 0) return;` only skips dead enemies (hp <= 0). This is correct — no change needed for the "always visible" requirement.
  </action>
  <verify>
    <automated>npm run build 2>&1 | tail -10</automated>
    <manual>npm run dev — open browser Performance tab, observe frame time with 8+ enemies on screen. With dirty flag: frame time should be stable when enemies are not being shot. Get TwinLaser — while beam is active, HP bar should visibly drain in real-time (frame by frame as laser ticks at 100ms intervals).</manual>
  </verify>
  <done>drawEnemyHealthBars() skips clear+redraw when no enemy HP or shield has changed; HP bars drain visibly in real-time during TwinLaser contact (100ms ticks cause redraws); build is clean</done>
</task>

</tasks>

<verification>
After Plan 03 completes, verify CMBT-02 and POL-03 criteria:
1. Activate TwinLaser (P01) → aim at enemy → cyan pulsing glow ring appears around the targeted enemy — POL-03 passed
2. Hold TwinLaser beam on enemy → HP bar drains frame by frame, not snapping to new value — CMBT-02 passed
3. Kill enemy with TwinLaser → brief glow linger at kill position before explosion
4. With beam active, confirm spark particles still emit from contact point (existing behavior preserved)
5. Enemy HP bars still visible when no shooting is happening — dirty flag doesn't break rendering
6. No console errors; `npm run build` exits 0
</verification>

<success_criteria>
- Cyan pulsing glow ring visible on beam-targeted enemy (strokeCircle in drawEffects, outside origins loop)
- TwinLaser kills show 100ms linger glow at kill position via _lingerTarget storage
- HP bars drain in real-time during laser contact (per-frame dirty flag detects 100ms HP ticks)
- Dirty-flag guard skips Graphics.clear()+redraw when no HP has changed — STATE.md performance concern resolved
- Build clean
</success_criteria>

<output>
After completion, create `.planning/phases/03-weapon-feedback/03-03-SUMMARY.md` summarizing:
- The _lingerTarget pattern (stored on TwinLaser instance, endTime comparison in drawEffects)
- The dirty-flag approach chosen (frame-level anyChanged check vs per-enemy) and the tradeoff
- Confirmation that CMBT-02 real-time drain works correctly with 100ms laser tick interval
- Any deviations from the plan
</output>
